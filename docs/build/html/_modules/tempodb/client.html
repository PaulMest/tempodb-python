<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>tempodb.client &mdash; TempoDB Python API 1.0b documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.0b',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="TempoDB Python API 1.0b documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">TempoDB Python API 1.0b documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for tempodb.client</h1><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">urlparse</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">endpoint</span>
<span class="kn">import</span> <span class="nn">protocol</span>
<span class="kn">from</span> <span class="nn">response</span> <span class="kn">import</span> <span class="n">Response</span>
<span class="kn">from</span> <span class="nn">temporal.validate</span> <span class="kn">import</span> <span class="n">check_time_param</span>


<div class="viewcode-block" id="make_series_url"><a class="viewcode-back" href="../../client.html#tempodb.client.make_series_url">[docs]</a><span class="k">def</span> <span class="nf">make_series_url</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given a series key, generate a valid URL to the series endpoint for</span>
<span class="sd">    that key.</span>

<span class="sd">    :param string key: the series key</span>
<span class="sd">    :rtype: string&quot;&quot;&quot;</span>

    <span class="n">url</span> <span class="o">=</span> <span class="n">urlparse</span><span class="o">.</span><span class="n">urljoin</span><span class="p">(</span><span class="n">endpoint</span><span class="o">.</span><span class="n">SERIES_ENDPOINT</span><span class="p">,</span> <span class="s">&#39;key/&#39;</span><span class="p">)</span>
    <span class="n">url</span> <span class="o">=</span> <span class="n">urlparse</span><span class="o">.</span><span class="n">urljoin</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">url</span>

</div>
<div class="viewcode-block" id="with_response_type"><a class="viewcode-back" href="../../client.html#tempodb.client.with_response_type">[docs]</a><span class="k">class</span> <span class="nc">with_response_type</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decorator for ensuring the Response object returned by the</span>
<span class="sd">    :class:`Client` object has a data attribute that corresponds to the</span>
<span class="sd">    object type expected from the TempoDB API.  This class should not be</span>
<span class="sd">    used by user code.</span>

<span class="sd">    The &quot;t&quot; argument should be a string corresponding to the name of a class</span>
<span class="sd">    from the :mod:`tempodb.protocol.objects` module, or a single element list</span>
<span class="sd">    with the element being the name of a class from that module if the API</span>
<span class="sd">    endpoint will return a list of those objects.</span>

<span class="sd">    :param t: the type of object to cast the TempoDB response to</span>
<span class="sd">    :type t: list or string&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">t</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">resp</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="c">#dont try this at home kids</span>
            <span class="n">session</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">session</span>
            <span class="n">resp_obj</span> <span class="o">=</span> <span class="n">Response</span><span class="p">(</span><span class="n">resp</span><span class="p">,</span> <span class="n">session</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">resp_obj</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="mi">200</span><span class="p">:</span>
                <span class="n">resp_obj</span><span class="o">.</span><span class="n">_cast_payload</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">resp_obj</span>
        <span class="k">return</span> <span class="n">wrapper</span>

</div>
<div class="viewcode-block" id="Client"><a class="viewcode-back" href="../../client.html#tempodb.client.Client">[docs]</a><span class="k">class</span> <span class="nc">Client</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Entry point class into the TempoDB API.  The client should be</span>
<span class="sd">    initialized with your API key and secret obtained from your TempoDB</span>
<span class="sd">    login.</span>

<span class="sd">    The methods are grouped as follows:</span>

<span class="sd">    SERIES</span>

<span class="sd">        * :meth:`create_series`</span>
<span class="sd">        * :meth:`delete_series`</span>
<span class="sd">        * :meth:`get_series`</span>
<span class="sd">        * :meth:`list_series`</span>
<span class="sd">        * :meth:`update_series`</span>

<span class="sd">    READING DATA</span>

<span class="sd">        * :meth:`read_data`</span>
<span class="sd">        * :meth:`read_multi`</span>

<span class="sd">    WRITING DATA</span>

<span class="sd">        * :meth:`write_data`</span>
<span class="sd">        * :meth:`write_multi`</span>

<span class="sd">    DELETING</span>

<span class="sd">        * :meth:`delete`</span>

<span class="sd">    SINGLE VALUE</span>

<span class="sd">        * :meth:`single_value`</span>
<span class="sd">        * :meth:`single_value_multi_series`</span>

<span class="sd">    :param string key: your API key</span>
<span class="sd">    :param string secret: your API secret&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">secret</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="n">endpoint</span><span class="o">.</span><span class="n">HTTPEndpoint</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">secret</span><span class="p">,</span>
                                             <span class="n">endpoint</span><span class="o">.</span><span class="n">BASE_URL</span><span class="p">)</span>

    <span class="c">#SERIES METHODS</span>
    <span class="nd">@with_response_type</span><span class="p">(</span><span class="s">&#39;Nothing&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="Client.create_series"><a class="viewcode-back" href="../../client.html#tempodb.client.Client.create_series">[docs]</a>    <span class="k">def</span> <span class="nf">create_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new series with an optional string key.</span>

<span class="sd">        :param string key: (optional) a string key for the series</span>
<span class="sd">        :rtype: :class:`tempodb.response.Response` object&quot;&quot;&quot;</span>

        <span class="n">body</span> <span class="o">=</span> <span class="s">&#39;&#39;</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">protocol</span><span class="o">.</span><span class="n">make_series_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="n">endpoint</span><span class="o">.</span><span class="n">SERIES_ENDPOINT</span><span class="p">,</span> <span class="n">body</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">resp</span>
</div>
    <span class="nd">@with_response_type</span><span class="p">(</span><span class="s">&#39;Nothing&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="Client.delete_series"><a class="viewcode-back" href="../../client.html#tempodb.client.Client.delete_series">[docs]</a>    <span class="k">def</span> <span class="nf">delete_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">series_id</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                      <span class="n">allow_truncation</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete a series according to the given criteria.</span>

<span class="sd">        **Note:** for the series_id and key arguments, the filter will</span>
<span class="sd">        return the *union* of those values.  For the tag and attr</span>
<span class="sd">        arguments, the filter will return the *intersection* of those</span>
<span class="sd">        values.</span>

<span class="sd">        :param series_id: filter by one or more series IDs</span>
<span class="sd">        :type series_id: list or string</span>
<span class="sd">        :param key: filter by one or more series keys</span>
<span class="sd">        :type key: list or string</span>
<span class="sd">        :param tag: filter by one or more tags</span>
<span class="sd">        :type tag: list or string</span>
<span class="sd">        :param dict attr: filter by one or more key-value attributes</span>
<span class="sd">        :param bool allow_truncation: whether to allow full deletion of a</span>
<span class="sd">                                      database</span>
<span class="sd">        :rtype: :class:`tempodb.response.Response` object&quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">&#39;id&#39;</span><span class="p">:</span> <span class="n">series_id</span><span class="p">,</span>
            <span class="s">&#39;key&#39;</span><span class="p">:</span> <span class="n">key</span><span class="p">,</span>
            <span class="s">&#39;tag&#39;</span><span class="p">:</span> <span class="n">tag</span><span class="p">,</span>
            <span class="s">&#39;attr&#39;</span><span class="p">:</span> <span class="n">attr</span><span class="p">,</span>
            <span class="s">&#39;allow_truncation&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">allow_truncation</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="n">url_args</span> <span class="o">=</span> <span class="n">endpoint</span><span class="o">.</span><span class="n">make_url_args</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">url</span> <span class="o">=</span> <span class="s">&#39;?&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">endpoint</span><span class="o">.</span><span class="n">SERIES_ENDPOINT</span><span class="p">,</span> <span class="n">url_args</span><span class="p">])</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">resp</span>
</div>
    <span class="nd">@with_response_type</span><span class="p">(</span><span class="s">&#39;Series&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="Client.get_series"><a class="viewcode-back" href="../../client.html#tempodb.client.Client.get_series">[docs]</a>    <span class="k">def</span> <span class="nf">get_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a series object from TempoDB given its key.</span>

<span class="sd">        :param string key:a string name for the series</span>
<span class="sd">        :rtype: :class:`tempodb.response.Response` object&quot;&quot;&quot;</span>

        <span class="n">url</span> <span class="o">=</span> <span class="n">make_series_url</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">resp</span>
</div>
    <span class="nd">@with_response_type</span><span class="p">(</span><span class="s">&#39;SeriesSet&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="Client.list_series"><a class="viewcode-back" href="../../client.html#tempodb.client.Client.list_series">[docs]</a>    <span class="k">def</span> <span class="nf">list_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">series_id</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                    <span class="n">limit</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a list of all series matching the given criteria.</span>

<span class="sd">        **Note:** for the series_id and key arguments, the filter will</span>
<span class="sd">        return the *union* of those values.  For the tag and attr</span>
<span class="sd">        arguments, the filter will return the *intersection* of those</span>
<span class="sd">        values.</span>

<span class="sd">        :param series_id: filter by one or more series IDs</span>
<span class="sd">        :type series_id: list or string</span>
<span class="sd">        :param key: filter by one or more series keys</span>
<span class="sd">        :type key: list or string</span>
<span class="sd">        :param tag: filter by one or more tags</span>
<span class="sd">        :type tag: list or string</span>
<span class="sd">        :param dict attr: filter by one or more key-value attributes</span>
<span class="sd">        :rtype: :class:`tempodb.response.Response` object&quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">&#39;id&#39;</span><span class="p">:</span> <span class="n">series_id</span><span class="p">,</span>
            <span class="s">&#39;key&#39;</span><span class="p">:</span> <span class="n">key</span><span class="p">,</span>
            <span class="s">&#39;tag&#39;</span><span class="p">:</span> <span class="n">tag</span><span class="p">,</span>
            <span class="s">&#39;attr&#39;</span><span class="p">:</span> <span class="n">attr</span><span class="p">,</span>
            <span class="s">&#39;limit&#39;</span><span class="p">:</span> <span class="n">limit</span>
        <span class="p">}</span>
        <span class="n">url_args</span> <span class="o">=</span> <span class="n">endpoint</span><span class="o">.</span><span class="n">make_url_args</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">url</span> <span class="o">=</span> <span class="s">&#39;?&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">endpoint</span><span class="o">.</span><span class="n">SERIES_ENDPOINT</span><span class="p">,</span> <span class="n">url_args</span><span class="p">])</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">resp</span>
</div>
    <span class="nd">@with_response_type</span><span class="p">(</span><span class="s">&#39;Series&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="Client.update_series"><a class="viewcode-back" href="../../client.html#tempodb.client.Client.update_series">[docs]</a>    <span class="k">def</span> <span class="nf">update_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">series</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update a series with new attributes.  This does not change</span>
<span class="sd">        any of the data written to this series. The recommended workflow for</span>
<span class="sd">        series updates is to pull a Series object down using the</span>
<span class="sd">        :meth:`get_series` method, change its attributes, then pass it into</span>
<span class="sd">        this method.</span>

<span class="sd">        :param series: the series to update</span>
<span class="sd">        :type series: `tempodb.protocol.Series` object</span>
<span class="sd">        :rtype: :class:`tempodb.response.Response` object&quot;&quot;&quot;</span>

        <span class="n">url</span> <span class="o">=</span> <span class="n">urlparse</span><span class="o">.</span><span class="n">urljoin</span><span class="p">(</span><span class="n">endpoint</span><span class="o">.</span><span class="n">SERIES_ENDPOINT</span><span class="p">,</span> <span class="s">&#39;key/&#39;</span><span class="p">)</span>
        <span class="n">url</span> <span class="o">=</span> <span class="n">urlparse</span><span class="o">.</span><span class="n">urljoin</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">series</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>

        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">series</span><span class="o">.</span><span class="n">to_json</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">resp</span>

    <span class="c">#DATA READING METHODS</span></div>
    <span class="nd">@with_response_type</span><span class="p">(</span><span class="s">&#39;DataSet&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="Client.read_data"><a class="viewcode-back" href="../../client.html#tempodb.client.Client.read_data">[docs]</a>    <span class="k">def</span> <span class="nf">read_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                  <span class="n">interval</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read data from a series given its ID or key.  Start and end times</span>
<span class="sd">        must be supplied.  They can either be ISO8601 encoded strings (i.e.</span>
<span class="sd">        2012-01-08T00:21:54.000+0000) or Python Datetime objects, which will</span>
<span class="sd">        be converted for you.</span>

<span class="sd">        The function parameter is optional and can include string values such</span>
<span class="sd">        as &quot;sum&quot; and &quot;avg&quot;.  This will apply a folding function to your</span>
<span class="sd">        rollup of data.  The optional interval parameter will downsample your</span>
<span class="sd">        data according to the given resolution (&quot;1min&quot;, &quot;2day&quot;, etc).</span>

<span class="sd">        Finally, the optional tz parameter can be used to specify a time zone</span>
<span class="sd">        for your output.  Please see</span>
<span class="sd">        `here &lt;https://tempo-db.com/docs/api/timezone/&gt;`_ for a list of a</span>
<span class="sd">        valid timezone values.</span>

<span class="sd">        :param string key: the series key to use</span>
<span class="sd">        :param start: the start time for the data points</span>
<span class="sd">        :type start: string or Datetime</span>
<span class="sd">        :param end: the end time for the data points</span>
<span class="sd">        :type end: string or Datetime</span>
<span class="sd">        :param string function: (optional) the name of a rollup function to use</span>
<span class="sd">        :param string interval: (optional) downsampling rate for the data</span>
<span class="sd">        :param string tz: (optional) the timezone to place the data into</span>
<span class="sd">        :rtype: :class:`tempodb.response.Response` object&quot;&quot;&quot;</span>

        <span class="n">url</span> <span class="o">=</span> <span class="n">make_series_url</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">url</span> <span class="o">=</span> <span class="n">urlparse</span><span class="o">.</span><span class="n">urljoin</span><span class="p">(</span><span class="n">url</span> <span class="o">+</span> <span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="s">&#39;segment&#39;</span><span class="p">)</span>

        <span class="n">vstart</span> <span class="o">=</span> <span class="n">check_time_param</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">vend</span> <span class="o">=</span> <span class="n">check_time_param</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">&#39;start&#39;</span><span class="p">:</span> <span class="n">vstart</span><span class="p">,</span>
            <span class="s">&#39;end&#39;</span><span class="p">:</span> <span class="n">vend</span><span class="p">,</span>
            <span class="s">&#39;rollup.fold&#39;</span><span class="p">:</span> <span class="n">function</span><span class="p">,</span>
            <span class="s">&#39;rollup.period&#39;</span><span class="p">:</span> <span class="n">interval</span><span class="p">,</span>
            <span class="s">&#39;tz&#39;</span><span class="p">:</span> <span class="n">tz</span><span class="p">,</span>
            <span class="s">&#39;limit&#39;</span><span class="p">:</span> <span class="n">limit</span>
        <span class="p">}</span>
        <span class="n">url_args</span> <span class="o">=</span> <span class="n">endpoint</span><span class="o">.</span><span class="n">make_url_args</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">url</span> <span class="o">=</span> <span class="s">&#39;?&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">url</span><span class="p">,</span> <span class="n">url_args</span><span class="p">])</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">resp</span>

    <span class="c">#@with_response_type([&#39;DataSet&#39;])</span>
    <span class="c">#def read_multi(self, key=None, start=None, end=None,</span>
    <span class="c">#               function=None, interval=None, tz=None, tag=None,</span>
    <span class="c">#               attr=None):</span>
    <span class="c">#    &quot;&quot;&quot;Read data from multiple series given filter criteria.  See the</span>
    <span class="c">#    :meth:`list_series` method for a description of how the filter</span>
    <span class="c">#    criteria are applied, and the :meth:`read_data` method for how to</span>
    <span class="c">#    work with the start, end, function, interval, and tz parameters.</span>
    <span class="c">#</span>
    <span class="c">#    :param series_id: (optional) filter by one or more series IDs</span>
    <span class="c">#    :type series_id: list or string</span>
    <span class="c">#    :param key: (optional) filter by one or more series keys</span>
    <span class="c">#    :type key: list or string</span>
    <span class="c">#    :param tag: filter by one or more tags</span>
    <span class="c">#    :type tag: list or string</span>
    <span class="c">#    :param dict attr: (optional) filter by one or more key-value attributes</span>
    <span class="c">#    :param start: the start time for the data points</span>
    <span class="c">#    :type start: string or Datetime</span>
    <span class="c">#    :param end: the end time for the data points</span>
    <span class="c">#    :type end: string or Datetime</span>
    <span class="c">#    :param string function: (optional) the name of a rollup function to use</span>
    <span class="c">#    :param string interval: (optional) downsampling rate for the data</span>
    <span class="c">#    :param string tz: (optional) the timezone to place the data into</span>
    <span class="c">#    :rtype: :class:`tempodb.response.Response` object&quot;&quot;&quot;</span>
<span class="c">#</span>
    <span class="c">#    url = &#39;data&#39;</span>
<span class="c">#</span>
    <span class="c">#    vstart = check_time_param(start)</span>
    <span class="c">#    vend = check_time_param(end)</span>
    <span class="c">#    params = {</span>
    <span class="c">#        &#39;key&#39;: key,</span>
    <span class="c">#        &#39;tag&#39;: tag,</span>
    <span class="c">#        &#39;attr&#39;: attr,</span>
    <span class="c">#        &#39;start&#39;: vstart,</span>
    <span class="c">#        &#39;end&#39;: vend,</span>
    <span class="c">#        &#39;function&#39;: function,</span>
    <span class="c">#        &#39;interval&#39;: interval,</span>
    <span class="c">#        &#39;tz&#39;: tz</span>
    <span class="c">#    }</span>
    <span class="c">#    url_args = endpoint.make_url_args(params)</span>
    <span class="c">#    url = &#39;?&#39;.join([url, url_args])</span>
    <span class="c">#    resp = self.session.get(url)</span>
    <span class="c">#    return resp</span>

    <span class="c">#WRITE DATA METHODS</span></div>
    <span class="nd">@with_response_type</span><span class="p">(</span><span class="s">&#39;Nothing&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="Client.write_data"><a class="viewcode-back" href="../../client.html#tempodb.client.Client.write_data">[docs]</a>    <span class="k">def</span> <span class="nf">write_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">tags</span><span class="o">=</span><span class="p">[],</span> <span class="n">attrs</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;Write a set a datapoints into a series by its key.  For now,</span>
<span class="sd">        the tags and attributes arguments are ignored.</span>

<span class="sd">        :param string key: the series to write data into</span>
<span class="sd">        :param list data: a list of DataPoints to write</span>
<span class="sd">        :rtype: :class:`tempodb.response.Response` object&quot;&quot;&quot;</span>

        <span class="n">url</span> <span class="o">=</span> <span class="n">make_series_url</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">url</span> <span class="o">=</span> <span class="n">urlparse</span><span class="o">.</span><span class="n">urljoin</span><span class="p">(</span><span class="n">url</span> <span class="o">+</span> <span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="s">&#39;data&#39;</span><span class="p">)</span>

        <span class="c">#revisit later if there are server changes to take these into</span>
        <span class="c">#account</span>
        <span class="c">#params = {</span>
        <span class="c">#    &#39;tag&#39;: tag,</span>
        <span class="c">#    &#39;attr&#39;: attr,</span>
        <span class="c">#}</span>
        <span class="c">#url_args = endpoint.make_url_args(params)</span>
        <span class="c">#url = &#39;?&#39;.join([url, url_args])</span>

        <span class="n">dlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">to_dictionary</span><span class="p">()</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
        <span class="n">body</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">dlist</span><span class="p">)</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">body</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">resp</span>
</div>
    <span class="nd">@with_response_type</span><span class="p">(</span><span class="s">&#39;Nothing&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="Client.write_multi"><a class="viewcode-back" href="../../client.html#tempodb.client.Client.write_multi">[docs]</a>    <span class="k">def</span> <span class="nf">write_multi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write a set a datapoints into multiple series by key or series ID.</span>
<span class="sd">        Each :class:`tempodb.protocol.objects.DataPoint` object should have</span>
<span class="sd">        either a key or id attribute set that indicates which series it will</span>
<span class="sd">        be written into::</span>

<span class="sd">            [</span>
<span class="sd">                {&quot;t&quot;: &quot;2012-...&quot;, &quot;key&quot;: &quot;foo&quot;, &quot;v&quot;: 1},</span>
<span class="sd">                {&quot;t&quot;: &quot;2012-...&quot;, &quot;id&quot;: &quot;bar&quot;, &quot;v&quot;: 1}</span>
<span class="sd">            ]</span>

<span class="sd">        If a non-existent key or ID is passed in, a series will be created</span>
<span class="sd">        for that key/ID and the data point written in to the new series.</span>

<span class="sd">        :param list data: a list of DataPoints to write</span>
<span class="sd">        :rtype: :class:`tempodb.response.Response` object&quot;&quot;&quot;</span>

        <span class="n">url</span> <span class="o">=</span> <span class="s">&#39;multi/&#39;</span>

        <span class="n">dlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">to_dictionary</span><span class="p">()</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
        <span class="n">body</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">dlist</span><span class="p">)</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">body</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">resp</span>

    <span class="c">#INCREMENT METHODS</span>
    <span class="c">#@with_response_type(&#39;Nothing&#39;)</span>
    <span class="c">#def increment(self, key, data=[]):</span>
    <span class="c">#    &quot;&quot;&quot;Increment a series a data points by the specified amount.  For</span>
    <span class="c">#    instance, incrementing with the following data::</span>
<span class="c">#</span>
    <span class="c">#        data = [{&quot;t&quot;: &quot;2012-01-08T00:21:54.000+0000&quot;, &quot;v&quot;: 4.164}]</span>
<span class="c">#</span>
    <span class="c">#    would increment the value at that time by 4.</span>
<span class="c">#</span>
    <span class="c">#    **Note:** all floating point values are converted to longs before</span>
    <span class="c">#    the increment takes place.</span>
<span class="c">#</span>
    <span class="c">#    :param string key: the series whose value to increment</span>
    <span class="c">#    :param list data: the data points to incrememnt</span>
    <span class="c">#    :rtype: :class:`tempodb.response.Response` object&quot;&quot;&quot;</span>

    <span class="c">#    url = make_series_url(key)</span>
    <span class="c">#    url = urlparse.urljoin(url + &#39;/&#39;, &#39;increment&#39;)</span>
    <span class="c">#    dlist = [d.to_dictionary() for d in data]</span>
    <span class="c">#    body = json.dumps(dlist)</span>
    <span class="c">#    resp = self.session.post(url, body)</span>
    <span class="c">#    return resp</span>

    <span class="c">#SINGLE VALUE METHODS</span></div>
    <span class="nd">@with_response_type</span><span class="p">(</span><span class="s">&#39;SingleValue&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="Client.single_value"><a class="viewcode-back" href="../../client.html#tempodb.client.Client.single_value">[docs]</a>    <span class="k">def</span> <span class="nf">single_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">ts</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a single value for a series.  You can supply a timestamp</span>
<span class="sd">        as the ts argument, otherwise the search defaults to the current</span>
<span class="sd">        time.</span>

<span class="sd">        The dire`ction argument can be one of &quot;exact&quot;, &quot;before&quot;, &quot;after&quot;, or</span>
<span class="sd">        &quot;nearest&quot;.</span>

<span class="sd">        :param string key: the key for the series to use</span>
<span class="sd">        :param ts: (optional) the time to begin searching from</span>
<span class="sd">        :type ts: ISO8601 string or Datetime object</span>
<span class="sd">        :param string direction: criterion for the search</span>
<span class="sd">        :rtype: :class:`tempodb.response.Response` object&quot;&quot;&quot;</span>

        <span class="n">url</span> <span class="o">=</span> <span class="n">make_series_url</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">url</span> <span class="o">=</span> <span class="n">urlparse</span><span class="o">.</span><span class="n">urljoin</span><span class="p">(</span><span class="n">url</span> <span class="o">+</span> <span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="s">&#39;single&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">vts</span> <span class="o">=</span> <span class="n">check_time_param</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vts</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">&#39;ts&#39;</span><span class="p">:</span> <span class="n">vts</span><span class="p">,</span>
            <span class="s">&#39;direction&#39;</span><span class="p">:</span> <span class="n">direction</span>
        <span class="p">}</span>

        <span class="n">url_args</span> <span class="o">=</span> <span class="n">endpoint</span><span class="o">.</span><span class="n">make_url_args</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">url</span> <span class="o">=</span> <span class="s">&#39;?&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">url</span><span class="p">,</span> <span class="n">url_args</span><span class="p">])</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">resp</span>
</div>
    <span class="nd">@with_response_type</span><span class="p">([</span><span class="s">&#39;SingleValue&#39;</span><span class="p">])</span>
<div class="viewcode-block" id="Client.multi_series_single_value"><a class="viewcode-back" href="../../client.html#tempodb.client.Client.multi_series_single_value">[docs]</a>    <span class="k">def</span> <span class="nf">multi_series_single_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ts</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                                  <span class="n">attr</span><span class="o">=</span><span class="p">{},</span> <span class="n">tag</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;Return a single value for multiple series.  You can supply a</span>
<span class="sd">        timestamp as the ts argument, otherwise the search defaults to the</span>
<span class="sd">        current time.</span>

<span class="sd">        The direction argument can be one of &quot;exact&quot;, &quot;before&quot;, &quot;after&quot;, or</span>
<span class="sd">        &quot;nearest&quot;.</span>

<span class="sd">        The id, key, tag, and attr arguments allow you to filter for series.</span>
<span class="sd">        See the :meth:`list_series` method for an explanation of their use.</span>

<span class="sd">        :param string key: (optional) a list of keys for the series to use</span>
<span class="sd">        :param ts: (optional) the time to begin searching from</span>
<span class="sd">        :type ts: ISO8601 string or Datetime object</span>
<span class="sd">        :param string direction: criterion for the search</span>
<span class="sd">        :param tag: filter by one or more tags</span>
<span class="sd">        :type tag: list or string</span>
<span class="sd">        :param dict attr: filter by one or more key-value attributes</span>
<span class="sd">        :rtype: :class:`tempodb.response.Response` object&quot;&quot;&quot;</span>

        <span class="n">url</span> <span class="o">=</span> <span class="s">&#39;single/&#39;</span>
        <span class="k">if</span> <span class="n">ts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">vts</span> <span class="o">=</span> <span class="n">check_time_param</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vts</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">&#39;key&#39;</span><span class="p">:</span> <span class="n">key</span><span class="p">,</span>
            <span class="s">&#39;tag&#39;</span><span class="p">:</span> <span class="n">tag</span><span class="p">,</span>
            <span class="s">&#39;attr&#39;</span><span class="p">:</span> <span class="n">attr</span><span class="p">,</span>
            <span class="s">&#39;ts&#39;</span><span class="p">:</span> <span class="n">vts</span><span class="p">,</span>
            <span class="s">&#39;direction&#39;</span><span class="p">:</span> <span class="n">direction</span>
        <span class="p">}</span>

        <span class="n">url_args</span> <span class="o">=</span> <span class="n">endpoint</span><span class="o">.</span><span class="n">make_url_args</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">url</span> <span class="o">=</span> <span class="s">&#39;?&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">url</span><span class="p">,</span> <span class="n">url_args</span><span class="p">])</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">resp</span>
</div>
    <span class="nd">@with_response_type</span><span class="p">(</span><span class="s">&#39;Nothing&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="Client.delete"><a class="viewcode-back" href="../../client.html#tempodb.client.Client.delete">[docs]</a>    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deletes data in a given series over the timeframe specified</span>
<span class="sd">        by start and end.</span>

<span class="sd">        :param string key: a list of keys for the series to use</span>
<span class="sd">        :param start: the time to begin deleting from</span>
<span class="sd">        :type start: ISO8601 string or Datetime object</span>
<span class="sd">        :param end: the time to end deleting at</span>
<span class="sd">        :type end: ISO8601 string or Datetime object</span>
<span class="sd">        :rtype: :class:`tempodb.response.Response` object&quot;&quot;&quot;</span>

        <span class="n">url</span> <span class="o">=</span> <span class="n">make_series_url</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">url</span> <span class="o">=</span> <span class="n">urlparse</span><span class="o">.</span><span class="n">urljoin</span><span class="p">(</span><span class="n">url</span> <span class="o">+</span> <span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="s">&#39;data&#39;</span><span class="p">)</span>
        <span class="n">vstart</span> <span class="o">=</span> <span class="n">check_time_param</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">vend</span> <span class="o">=</span> <span class="n">check_time_param</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">&#39;start&#39;</span><span class="p">:</span> <span class="n">vstart</span><span class="p">,</span>
            <span class="s">&#39;end&#39;</span><span class="p">:</span> <span class="n">vend</span>
        <span class="p">}</span>

        <span class="n">url_args</span> <span class="o">=</span> <span class="n">endpoint</span><span class="o">.</span><span class="n">make_url_args</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">url</span> <span class="o">=</span> <span class="s">&#39;?&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">url</span><span class="p">,</span> <span class="n">url_args</span><span class="p">])</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">resp</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">TempoDB Python API 1.0b documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Aaron Brenzel.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.
    </div>
  </body>
</html>